function [Y,Xf,Af] = Predict_Irrigation(X,~,~)
%MYNEURALNETWORKFUNCTION neural network simulation function.
%
% Generated by Neural Network Toolbox function genFunction, 05-Jul-2017 18:50:44.
%
% [Y] = myNeuralNetworkFunction(X,~,~) takes these arguments:
%
%   X = 1xTS cell, 1 inputs over TS timesteps
%   Each X{1,ts} = Qx4 matrix, input #1 at timestep ts.
%
% and returns:
%   Y = 1xTS cell of 1 outputs over TS timesteps.
%   Each Y{1,ts} = Qx1 matrix, output #1 at timestep ts.
%
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [519;519;0;0.035];
x1_step1.gain = [0.0125;0.0125;0.0242424242424242;0.349895035897908];
x1_step1.ymin = -1;

% Layer 1
b1 = [-1.486971014204943;-1.561988938619993;2.6041515293874165;-4.9112011865779888;-2.3363730350151841;-1.9435682321193379;-2.4419125584349777;-2.9037653163716994;-5.6235769381897471;-5.798095557518713];
IW1_1 = [-0.843042837496362 0.63781755197111001 3.1964568792314503 -3.3453907050109866;1.5237029359076548 1.8690697521038078 -1.3257259529651588 -0.030842277031921127;-0.57532755691468584 0.041444289957935823 1.3165120189282307 -1.456719906462878;-0.5679260397751541 0.535355160053264 3.2915484504272645 -7.2100479280082617;-3.492677269326605 3.4964794017759941 -1.6821802696779682 0.063431216189130377;3.0802090327280554 -1.3782919701126992 0.9966868516104922 0.82642349439342622;-1.7889882089753437 2.2060747522316593 -1.4207608869123791 -2.0106083252416354;-2.8815911945917541 1.0630385997567211 0.83534389891206839 -0.45424985674213447;-5.5906871530039828 1.5416394259248414 1.4218785555425772 -0.34132446672172861;-4.0975784750878148 -1.9958700450711764 2.846094254664453 -0.23838470153062646];

% Layer 2
b2 = -0.35679997883141884;
LW2_1 = [2.3269392175888051 -0.012222578513458952 -0.011915690300134792 -1.6040243608795597 1.1309923331641434 -0.0001158550622407566 0.019491906410050015 -2.3295197772531182 4.6866377112044058 -3.2448191782700682];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = 0.04;
y1_step1.xoffset = 0;

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(X);
if ~isCellX, X = {X}; end;

% Dimensions
TS = size(X,2); % timesteps
if ~isempty(X)
    Q = size(X{1},1); % samples/series
else
    Q = 0;
end

% Allocate Outputs
Y = cell(1,TS);

% Time loop
for ts=1:TS
    
    % Input 1
    X{1,ts} = X{1,ts}';
    Xp1 = mapminmax_apply(X{1,ts},x1_step1);
    
    % Layer 1
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*Xp1);
    
    % Layer 2
    a2 = repmat(b2,1,Q) + LW2_1*a1;
    
    % Output 1
    Y{1,ts} = mapminmax_reverse(a2,y1_step1);
    Y{1,ts} = Y{1,ts}';
end

% Final Delay States
Xf = cell(1,0);
Af = cell(2,0);

% Format Output Arguments
if ~isCellX, Y = cell2mat(Y); end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
y = bsxfun(@minus,x,settings.xoffset);
y = bsxfun(@times,y,settings.gain);
y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
x = bsxfun(@minus,y,settings.ymin);
x = bsxfun(@rdivide,x,settings.gain);
x = bsxfun(@plus,x,settings.xoffset);
end
