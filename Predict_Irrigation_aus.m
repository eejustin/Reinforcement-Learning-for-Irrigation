function [Y,Xf,Af] = Predict_Irrigation_aus(X,~,~)
%MYNEURALNETWORKFUNCTION neural network simulation function.
%
% Generated by Neural Network Toolbox function genFunction, 09-Jul-2017 01:24:25.
%
% [Y] = myNeuralNetworkFunction(X,~,~) takes these arguments:
%
%   X = 1xTS cell, 1 inputs over TS timesteps
%   Each X{1,ts} = Qx4 matrix, input #1 at timestep ts.
%
% and returns:
%   Y = 1xTS cell of 1 outputs over TS timesteps.
%   Each Y{1,ts} = Qx1 matrix, output #1 at timestep ts.
%
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [515;515;0;0.026000001];
x1_step1.gain = [0.0152671755725191;0.0152671755725191;2;0.627549408096057];
x1_step1.ymin = -1;

% Layer 1
b1 = [2.5606919605335858;-2.2120563752886686;-0.41456585585064859;1.7298592091831122;4.8386069108617216;1.1399978747445343;1.1816085362622633;3.1111615414440044;0.42444419588762816;-4.0104322953668294];
IW1_1 = [0.032594338073375528 -0.00034965137729884438 -2.4535950217306244 -0.44272235624445117;1.9113690710599545 -1.766715684830356 2.1750268750217909 0.88163999226531731;7.4406742579261103 3.1379073397805963 -3.0748537315842861 4.8029003892308086;0.086667605597315553 2.1918070637886151 -0.57514298477959647 5.7419628652102128;-2.5947731764803841 2.1392752632325722 2.4883690642295346 6.9771277327277721;13.976421428544112 -14.291303113603773 -0.10586466616161357 0.098249456815565184;1.8089242182077216 -1.8275281976725244 -0.03156433500120169 0.37045743124137726;8.7581094680985689 -4.1880348910485763 1.473963708870436 -3.3057759950478549;0.81218194927195353 -0.8209576670907569 -0.011593152539950882 -0.043845717521224077;-0.79459015240620523 2.6163688436094903 0.48531816776354175 1.9402356010881141];

% Layer 2
b2 = -0.32546619272767874;
LW2_1 = [2.6987631263489584 1.9581103240784838 -0.0036543812657513735 0.11742934501857272 0.55166715393841248 -0.2661735295685318 -4.0418849530578616 0.074431266389555301 5.5028840458276056 0.23463212467625172];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = 0.04;
y1_step1.xoffset = 0;

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(X);
if ~isCellX, X = {X}; end;

% Dimensions
TS = size(X,2); % timesteps
if ~isempty(X)
    Q = size(X{1},1); % samples/series
else
    Q = 0;
end

% Allocate Outputs
Y = cell(1,TS);

% Time loop
for ts=1:TS
    
    % Input 1
    X{1,ts} = X{1,ts}';
    Xp1 = mapminmax_apply(X{1,ts},x1_step1);
    
    % Layer 1
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*Xp1);
    
    % Layer 2
    a2 = repmat(b2,1,Q) + LW2_1*a1;
    
    % Output 1
    Y{1,ts} = mapminmax_reverse(a2,y1_step1);
    Y{1,ts} = Y{1,ts}';
end

% Final Delay States
Xf = cell(1,0);
Af = cell(2,0);

% Format Output Arguments
if ~isCellX, Y = cell2mat(Y); end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
y = bsxfun(@minus,x,settings.xoffset);
y = bsxfun(@times,y,settings.gain);
y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
x = bsxfun(@minus,y,settings.ymin);
x = bsxfun(@rdivide,x,settings.gain);
x = bsxfun(@plus,x,settings.xoffset);
end
