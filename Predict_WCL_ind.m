function [Y,Xf,Af] = Predict_WCL_ind(X,~,~)
%MYNEURALNETWORKFUNCTION neural network simulation function.
%
% Generated by Neural Network Toolbox function genFunction, 09-Jul-2017 16:42:52.
%
% [Y] = myNeuralNetworkFunction(X,~,~) takes these arguments:
%
%   X = 1xTS cell, 1 inputs over TS timesteps
%   Each X{1,ts} = Qx4 matrix, input #1 at timestep ts.
%
% and returns:
%   Y = 1xTS cell of 1 outputs over TS timesteps.
%   Each Y{1,ts} = Qx1 matrix, output #1 at timestep ts.
%
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [531;0;0.138999999;0];
x1_step1.gain = [0.00975609756097561;0.0757575768480257;0.411437975640519;0.04];
x1_step1.ymin = -1;

% Layer 1
b1 = [-2.2531650168871864;6.9826259997527655;3.9512630440666991;-2.5762280936921038;5.2310475925252371;-0.075479368094983429;1.1537467419219583;-4.4552588925557375;4.9858486321045294;7.196107033911054];
IW1_1 = [3.1753300872283536 5.687961852753963 0.70479527063311864 1.6291286467169321;-5.4904628872988193 -7.8975591009863146 2.539247041674626 3.0542873023535875;-0.18224437228927476 3.4954678831029953 5.1331938176819785 -0.090610332410547334;1.0457171720119982 -2.8372443472363753 0.53732334420117966 -1.5413964978046195;1.4682531738531561 0.78400256975723048 -4.1556283076262233 0.58907583067575686;-0.11713301199403058 -0.018714037445854981 0.010129095844477541 -0.030776721051965935;-0.72958384041779178 -2.4339500151096654 5.3012016130778896 -0.89479908214102588;-8.0115399269833532 2.5488580355722252 -2.9219013646436172 1.2121570084334938;-0.94827249304313876 1.6672828433162916 -8.4763549210657008 -0.0057874427552072668;7.1290147790916825 0.11764392276482663 0.4094302570514588 -0.19054588629312275];

% Layer 2
b2 = -0.24690091423051497;
LW2_1 = [-0.013372026891533283 -0.0072818459305584449 0.026272633464989023 0.019046779927318205 -0.011164378547026777 -8.5250519673999303 0.028123936289053596 -0.006823918760066678 -0.01772731521819192 -0.056241330959493095];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = 0.00975609756097561;
y1_step1.xoffset = 531;

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(X);
if ~isCellX, X = {X}; end;

% Dimensions
TS = size(X,2); % timesteps
if ~isempty(X)
    Q = size(X{1},1); % samples/series
else
    Q = 0;
end

% Allocate Outputs
Y = cell(1,TS);

% Time loop
for ts=1:TS
    
    % Input 1
    X{1,ts} = X{1,ts}';
    Xp1 = mapminmax_apply(X{1,ts},x1_step1);
    
    % Layer 1
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*Xp1);
    
    % Layer 2
    a2 = repmat(b2,1,Q) + LW2_1*a1;
    
    % Output 1
    Y{1,ts} = mapminmax_reverse(a2,y1_step1);
    Y{1,ts} = Y{1,ts}';
end

% Final Delay States
Xf = cell(1,0);
Af = cell(2,0);

% Format Output Arguments
if ~isCellX, Y = cell2mat(Y); end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
y = bsxfun(@minus,x,settings.xoffset);
y = bsxfun(@times,y,settings.gain);
y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
x = bsxfun(@minus,y,settings.ymin);
x = bsxfun(@rdivide,x,settings.gain);
x = bsxfun(@plus,x,settings.xoffset);
end
